<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
  <title>Ionic App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="format-detection" content="telephone=no">
  <meta name="msapplication-tap-highlight" content="no">

  <link rel="icon" type="image/x-icon" href="assets/icon/favicon.ico">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#4e8ef7">
  
  <!-- cordova.js required for cordova apps -->
  <script src="cordova.js"></script>

  <!-- un-comment this code to enable service worker
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js')
        .then(() => console.log('service worker installed'))
        .catch(err => console.log('Error', err));
    }
  </script>-->

  <link href="build/main.css" rel="stylesheet">

</head>
<body>

  <!-- Ionic's root component and where the app will load -->
  <ion-app></ion-app>

  <!-- The polyfills js is generated during the build process -->
  <script src="build/polyfills.js"></script>

  <!-- The bundle js is generated during the build process -->
  <script src="build/main.js"></script>

  <script>
      var canvas  = document.querySelector('#canvas'); 
      canvas.width = 1000;
      canvas.height = 1000;
      var context = canvas.getContext('2d');

      // Remplissage de l'arrière plan en blanc
      context.fillStyle = "rgba(255, 255, 255, 1)";
      context.fillRect(0,0,canvas.width,canvas.height);

      function Examen(nom, resultat, moyenne, ecartType, max) {
        this.nom = nom;
        this.resultat = resultat;
        this.moyenne = moyenne;
        this.ecartType = ecartType;
        this.max = max;
        this.coordResultat = { x : 0, y : 0};
        this.coordMoyMax = { x : 0, y : 0};
        this.coordMoyMin = { x : 0, y : 0};
        this.coordMoy = { x : 0, y : 0};
        this.coordLim = { x : 0, y : 0};
      }

      var data = [
        new Examen("test1",33,38,2,50),
        new Examen("test2",6,10,3,60),
        new Examen("test3",53,59,5,45),
        new Examen("test4",5,18,4,70),
        new Examen("test5",16,14,1.69,84),
        new Examen("test6",34,31.4,3,50)
      ];

      // Point qui se situe au milieu du canvas
      var middlePoint = {
        x : canvas.width/2,
        y : canvas.height/2
      };

      var maxValueArray = [];
      var exces = 40;

      // facteur d'agrandissement du diagramme
      const FACTOR = 250;

      /** 
       * Fonction qui permet de donner les coordonnées d'un point suivant un angle donné sur le cercle trigonométrique 
       * par rapport à un point de départ situé en haut du cercle trigo (rotation positive vers la gauche).
       * 
       * x et y sont les coordonnées du point de départ
       * value est l'angle (ex: Math.PI/4)
       * factor est le facteur d'agrandissement
       */
      function convert(value, x, y, factor) {
        var result = {
          x : x - factor * (Math.sin(value)),
          y : y + factor * (1 - Math.cos(value))
        };
        return result;
      } 

      function pythagore(x1,y1,x2,y2){
        return Math.sqrt(Math.pow(y2-y1,2)+Math.pow(x2-x1,2));
      }

      function computeCoord() {
        for(var i = 0, length = data.length; i < length; i++ ){
          // Calcul des coordonnées des points correspondants à la moyenne.
          var value = convert(i * 2 * Math.PI / data.length,  middlePoint.x,  middlePoint.y - FACTOR, FACTOR);
          data[i].coordMoy.y = value.y;
          data[i].coordMoy.x = value.x;

          // Calcul des paramètres
          var rayon = pythagore(middlePoint.x,middlePoint.y,data[i].coordMoy.x,data[i].coordMoy.y);
          var moy = data[i].moyenne;
          var norm = rayon / moy;
          
          var maxNormValue = norm * (data[i].moyenne + data[i].ecartType);
          var minNormValue = norm * (data[i].moyenne - data[i].ecartType);
          var resultNormValue = norm * data[i].resultat;

          var longueurDeltaMax = rayon - maxNormValue; 
          var longueurDeltaMin = rayon - minNormValue; 
          var longueurDeltaRes = rayon - resultNormValue; 

          // Utile pour le calcul des extremités
          maxValueArray.push(maxNormValue);

          // Calcul des coordonnées des points correspondants à la moyenne max.
          data[i].coordMoyMax.x = data[i].coordMoy.x + (middlePoint.x - data[i].coordMoy.x) * longueurDeltaMax / rayon;
          data[i].coordMoyMax.y = data[i].coordMoy.y + (middlePoint.y - data[i].coordMoy.y) * longueurDeltaMax / rayon;

          // Calcul des coordonnées des points correspondants à la moyenne min.
          data[i].coordMoyMin.x = data[i].coordMoy.x + (middlePoint.x - data[i].coordMoy.x) * longueurDeltaMin / rayon;
          data[i].coordMoyMin.y = data[i].coordMoy.y + (middlePoint.y - data[i].coordMoy.y) * longueurDeltaMin / rayon;

          // Calcul des coordonnées des points correspondants aux résultats.
          data[i].coordResultat.x = data[i].coordMoy.x + (middlePoint.x - data[i].coordMoy.x) * longueurDeltaRes / rayon;
          data[i].coordResultat.y = data[i].coordMoy.y + (middlePoint.y - data[i].coordMoy.y) * longueurDeltaRes / rayon;

        }

        // Calcul des coordonnées des points correspondants aux extrémités des lignes qui se croisent en leur centre.
        for(var i = 0, length = data.length; i < length; i++ ){

          var rayon = pythagore(middlePoint.x,middlePoint.y,data[i].coordMoy.x,data[i].coordMoy.y);
          var longueurDeltaExt = rayon - (Math.max(...maxValueArray) + exces);

          data[i].coordLim.x = data[i].coordMoy.x + (middlePoint.x - data[i].coordMoy.x) * longueurDeltaExt / rayon;
          data[i].coordLim.y = data[i].coordMoy.y + (middlePoint.y - data[i].coordMoy.y) * longueurDeltaExt / rayon;
        }
      }

      function drawPoints(style,prop,fill,lineWidth,cross){
        if(fill){
          context.fillStyle = style;
        } else {
          context.lineWidth = lineWidth ? lineWidth : "1";
          context.strokeStyle = style;
        }
        context.beginPath();
        context.moveTo(data[0][prop].x, data[0][prop].y);
        if(cross){
          context.lineTo(middlePoint.x,middlePoint.y);
        }
        for(var i = 1, length = data.length; i < length; i++ ){
          if(cross){
            context.moveTo(data[i][prop].x, data[i][prop].y);
            context.lineTo(middlePoint.x,middlePoint.y);
          } else {
            context.lineTo(data[i][prop].x,data[i][prop].y);
          }
        }
        context.closePath();
        if(fill){
          context.fill();
        } else {
          context.stroke();
        }
      }

      /**
       * Calcul des points
       */
      computeCoord();

      /**
       * Tracé des courbes
       */
      drawPoints("rgba(23, 145, 167, 0.3)","coordMoyMax",true);
      drawPoints("rgba(255, 255, 255, 1)","coordMoyMin",true);
      drawPoints("rgba(80, 0, 160, .6)","coordMoy",false,"3");
      drawPoints("rgba(255, 0, 0, .5)","coordResultat",true);
      drawPoints("rgba(255, 0, 0, 1)","coordResultat",false,"2");
      drawPoints("rgba(150, 150, 150, .5)","coordLim",false,"2",true);



      downloadLnk.addEventListener('click', function(){
          this.href = canvas.toDataURL('image/jpeg');
      }, false);



    </script>

</body>
</html>
