<!DOCTYPE html>
<html>
	<head>

	</head>
	<body>
		
		<canvas id="canvas">
		    <p>Désolé, votre navigateur ne supporte pas Canvas. Mettez-vous à jour</p>
		</canvas>
		<a id="downloadLnk" download="diagramme.jpg">Télécharger le diagramme</a>
		<script>
			var canvas  = document.querySelector('#canvas');
			canvas.width = 1000;
			canvas.height = 1000;
			var context = canvas.getContext('2d');

			// Remplissage de l'arrière plan en blanc
			context.fillStyle = "rgba(255, 255, 255, 1)";
			context.fillRect(0,0,canvas.width,canvas.height);

			function Examen(nom, resultat, moyenne, ecartType, max) {
				this.nom = nom;
				this.resultat = resultat;
				this.moyenne = moyenne;
				this.ecartType = ecartType;
				this.max = max;
				this.coordResultat = { x : 0, y : 0};
				this.coordMoyMax = { x : 0, y : 0};
				this.coordMoyMin = { x : 0, y : 0};
				this.coordMoy = { x : 0, y : 0};
				this.coordLim = { x : 0, y : 0};
			}

			var data = [
				new Examen("test1",33,38,2,50),
				new Examen("test2",6,10,3,60),
				new Examen("test3",53,59,5,45),
				new Examen("test4",5,18,4,70),
				new Examen("test5",16,14,1.69,84),
				new Examen("test6",34,31.4,3,50)
			];

			// Point qui se situe au milieu du canvas
			var middlePoint = {
				x : canvas.width/2,
				y : canvas.height/2
			};

			var exces = 75;

			// facteur d'agrandissement du diagramme
			const FACTOR = 250;

			/** 
			 * Fonction qui permet de donner les coordonnées d'un point suivant un angle donné sur le cercle trigonométrique 
			 * par rapport à un point de départ situé en haut du cercle trigo (rotation positive vers la gauche).
			 * 
			 * x et y sont les coordonnées du point de départ
			 * value est l'angle (ex: Math.PI/4)
			 * factor est le facteur d'agrandissement
			 */
			function convert(value, x, y, factor) {
				var result = {
					x : x - factor * (Math.sin(value)),
					y : y + factor * (1 - Math.cos(value))
				};
				return result;
			}	

			function pythagore(x1,y1,x2,y2){
				return Math.sqrt(Math.pow(y2-y1,2)+Math.pow(x2-x1,2));
			}

			function computeCoord() {
				for(var i = 0, length = data.length; i < length; i++ ){

					// Calcul des coordonnées des points correspondants à la moyenne max.
					var value = convert(i * 2 * Math.PI / data.length,  middlePoint.x,  middlePoint.y - FACTOR, FACTOR);
					data[i].coordMoyMax.y = value.y;
					data[i].coordMoyMax.x = value.x;

					// Calcul des paramètres
					var rayon = pythagore(middlePoint.x,middlePoint.y,data[i].coordMoyMax.x,data[i].coordMoyMax.y);
					var moyMax = data[i].moyenne + data[i].ecartType;
					var norm = rayon / moyMax;

					// Calcul des coordonnées des points correspondants à la moyenne min.
					var longueurBandeMoy = norm * data[i].ecartType * 2;
					data[i].coordMoyMin.x = data[i].coordMoyMax.x + (middlePoint.x - data[i].coordMoyMax.x) * longueurBandeMoy / rayon;
					data[i].coordMoyMin.y = data[i].coordMoyMax.y + (middlePoint.y - data[i].coordMoyMax.y) * longueurBandeMoy / rayon;

					// Calcul des coordonnées des points correspondants à la moyenne.
					longueurBandeMoy = norm * data[i].ecartType;
					data[i].coordMoy.x = data[i].coordMoyMax.x + (middlePoint.x - data[i].coordMoyMax.x) * longueurBandeMoy / rayon;
					data[i].coordMoy.y = data[i].coordMoyMax.y + (middlePoint.y - data[i].coordMoyMax.y) * longueurBandeMoy / rayon;

					// Calcul des coordonnées des points correspondants aux résultats.
					var longueurDeltaRes = rayon - (norm * data[i].resultat);
					data[i].coordResultat.x = data[i].coordMoyMax.x + (middlePoint.x - data[i].coordMoyMax.x) * longueurDeltaRes / rayon;
					data[i].coordResultat.y = data[i].coordMoyMax.y + (middlePoint.y - data[i].coordMoyMax.y) * longueurDeltaRes / rayon;

					// Calcul des coordonnées des points correspondants aux extrémités des lignes qui se croisent en leur centre.
					longueurDeltaRes = -exces;
					data[i].coordLim.x = data[i].coordMoyMax.x + (middlePoint.x - data[i].coordMoyMax.x) * longueurDeltaRes / rayon;
					data[i].coordLim.y = data[i].coordMoyMax.y + (middlePoint.y - data[i].coordMoyMax.y) * longueurDeltaRes / rayon;
				}
			}

			function drawPoints(style,prop,fill,lineWidth,cross){
				if(fill){
					context.fillStyle = style;
				} else {
					context.lineWidth = lineWidth ? lineWidth : "1";
					context.strokeStyle = style;
				}
				context.beginPath();
				context.moveTo(data[0][prop].x, data[0][prop].y);
				if(cross){
					context.lineTo(middlePoint.x,middlePoint.y);
				}
				for(var i = 1, length = data.length; i < length; i++ ){
					if(cross){
						context.moveTo(data[i][prop].x, data[i][prop].y);
						context.lineTo(middlePoint.x,middlePoint.y);
					} else {
						context.lineTo(data[i][prop].x,data[i][prop].y);
					}
				}
				context.closePath();
				if(fill){
					context.fill();
				} else {
					context.stroke();
				}
			}

			/**
			 * Calcul des points
			 */
			computeCoord();

			/**
			 * Tracé des courbes
			 */
			drawPoints("rgba(23, 145, 167, 0.5)","coordMoyMax",true);
			drawPoints("rgba(255, 255, 255, 1)","coordMoyMin",true);
			drawPoints("rgba(0, 0, 200, 1)","coordMoy",false,".5");
			drawPoints("rgba(255, 0, 0, .5)","coordResultat",true);
			drawPoints("rgba(255, 0, 0, 1)","coordResultat",false,"2");
			drawPoints("rgba(150, 150, 150, .5)","coordLim",false,"2",true);



			downloadLnk.addEventListener('click', function(){
			    this.href = canvas.toDataURL('image/jpeg');
			}, false);









		</script>
	</body>
</html>