<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
  <title>Ionic App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="format-detection" content="telephone=no">
  <meta name="msapplication-tap-highlight" content="no">

  <link rel="icon" type="image/x-icon" href="assets/icon/favicon.ico">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#4e8ef7">
  
  <!-- cordova.js required for cordova apps -->
  <script src="cordova.js"></script>

  <!-- un-comment this code to enable service worker
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js')
        .then(() => console.log('service worker installed'))
        .catch(err => console.log('Error', err));
    }
  </script>-->

  <link href="build/main.css" rel="stylesheet">

</head>
<body>

  <!-- Ionic's root component and where the app will load -->
  <ion-app></ion-app>

  <!-- The polyfills js is generated during the build process -->
  <script src="build/polyfills.js"></script>

  <!-- The bundle js is generated during the build process -->
  <script src="build/main.js"></script>

    <script>
    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                              window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

    var x=0;

    var canvas  = document.querySelector('#canvas'); 
    canvas.width = 1200;
    canvas.height = 1200;
    var context = canvas.getContext('2d');

    var type = "";

    // Fonction qui efface le contenu du canvas pour tout mettre en blanc
    function clearCanvas(){
      context.fillStyle = "rgba(255, 255, 255, 1)";
      context.fillRect(0,0,canvas.width,canvas.height);
    };

    function Examen(nom, categorie, resultat, moyenne, moyenneInf, moyenneSup) {
      this.nom = nom;
      this.categorie = categorie;
      this.resultat = resultat;
      this.moyenne = moyenne;
      this.moyenneInf = moyenneInf;
      this.moyenneSup = moyenneSup;
      this.coordResultat = { x : 0, y : 0};
      this.coordMoyMax = { x : 0, y : 0};
      this.coordMoyMin = { x : 0, y : 0};
      this.coordMoy = { x : 0, y : 0};
      this.coordLim = { x : 0, y : 0};
    }

    var data = [
      /*new Examen("SOMATOGNOSIES","(schéma corporel)",16,17,17-2,17+2),
      new Examen("BONHOMME DE GOODENOUGH","(schéma corporel)",4,6,6-2,6+2),
      new Examen("M ABC 2","(coordinations globales et fines, équilibre)",7,10,10-3,10+3),
      new Examen("EMG","(coordinations globales et fines, équilibre)",5,10.5,10.5-1.25,10.5+1.25),
      new Examen("SANTUCCI","(graphisme)",3,4,3,11),
      new Examen("FIGURE DE REY B - COPIE","(graphisme)",10,0,0,16),
      new Examen("FIGURE DE REY B - MÉMOIRE","(graphisme)",0,0,0,9.5)*/
      new Examen("SOMATOGNOSIES","(schéma corporel)",36,22,22-2,22+2),
      new Examen("M ABC 2","(coordinations globales et fines, équilibre)",2,10,10-3,10+3),
      new Examen("BENDER","(graphisme)",35,39,39-6,39+6),
      new Examen("BHK","(graphisme)",5.2/*18*/,11.6,11.6-4.3,11.6+4.3),
      new Examen("STAMBAK","(structuration temporelle)",8,15.7,15.7-3.27,15.7+3.27),
      new Examen("BARRAGE DES CLOCHES","(attention, concentration)",27,29,29-4.2,29+4.2)
    ];

    // Point qui se situe au milieu du canvas
    var middlePoint = {
      x : canvas.width/2,
      y : canvas.height/2
    };

    // Valeur de dépassement des lignes qui se croisent au milieu
    const EXCES = 60;

    // facteur d'agrandissement du diagramme
    const FACTOR = 250;

    const RETURNHEIGHT = 30;

    const MAXTEXTWIDTH = 300;

    /** 
     * Fonction qui permet de donner les coordonnées d'un point suivant un angle donné sur le cercle trigonométrique 
     * par rapport à un point de départ situé en haut du cercle trigo (rotation positive vers la gauche).
     * 
     * x et y sont les coordonnées du point de départ
     * value est l'angle (ex: Math.PI/4)
     * factor est le facteur d'agrandissement
     */
    function convert(value, x, y, factor) {
      var result = {
        x : x - factor * (Math.sin(value)),
        y : y + factor * (1 - Math.cos(value))
      };
      return result;
    } 

    /* Permet via Pythagore de calculer l'hypothénuse d'un triangle rectangle dont les coordonnées des points sont 
       {(x1,y1),(x1,y2),(x2,y2)}. Cela nous donnera la valeur de la longueur du segment [(x1,y1),(x2,y2)]
    */
    function pythagore(x1,y1,x2,y2){
      return Math.sqrt(Math.pow(y2-y1,2)+Math.pow(x2-x1,2));
    }

    function computeCoord(returnHeight, maxTextWidth) {
      if(type === "") {
        type = "MOY";
      }
      var typeProp;
      var denomProp;

      // Permet de calculer la valeur max d'un pic pour se caler sur cette valeur pour construire les lignes qui se croisent au milieu auquel on ajoute la valeur "exces" définie juste après.
      var maxValueArray = [];

      /* Permet de definir les données à utiliser pour créer la figure géométrique de référence, suivant les résultats il sera plus judicieux d'utiliser telle ou telle autre représentation
      */
      switch(type){
        case "MOY": typeProp = 'coordMoy'; denomProp = 'moyenne'; break;
        case "MIN": typeProp = 'coordMoyMin'; denomProp = 'moyenneInf'; break;
        case "MAX": typeProp = 'coordMoyMax'; denomProp = 'moyenneSup'; break;
        case "RES": typeProp = 'coordResultat'; denomProp = 'resultat'; break;
        default : typeProp = 'coordMoy'; denomProp = 'moyenne'; break;
      }

      // style des legendes et textes affiches
      context.font = "20pt Calibri,Geneva,Arial";
      context.fillStyle = "rgb(0,20,180)";
      //context.strokeStyle = "rgb(0,0,0)";
      //context.strokeText("Exemple de texte", 10, 20);
     
      for(var i = 0, length = data.length; i < length; i++ ){
        // Calcul des coordonnées des points de la figure geomertique de base.
        var value = convert(i * 2 * Math.PI / data.length,  middlePoint.x,  middlePoint.y - FACTOR, FACTOR);
        data[i][typeProp].y = value.y;
        data[i][typeProp].x = value.x;
        /**
         * Calcul des paramètres
         */ 
        var rayon = pythagore(middlePoint.x,middlePoint.y,data[i][typeProp].x,data[i][typeProp].y);  //longueur en pixel du rayon du cercle trigo
        var norm = rayon / data[i][denomProp];            //nombre de pixel pour 1 unite de resultat/moyenne/...
        if(data[i][denomProp] == 0) norm = 0;
        var maxPixelValue = norm * data[i].moyenneSup;    //nombre de pixel correspondant à la valeur moyenne sup.
        var moyPixelValue = norm * data[i].moyenne;       //nombre de pixel correspondant à la valeur moyenne
        var minPixelValue = norm * data[i].moyenneInf;    //nombre de pixel correspondant à la valeur moyenne inf.
        var resultPixelValue = norm * data[i].resultat;   //nombre de pixel correspondant à la valeur resultat
        var deltaMoy = rayon - moyPixelValue;     //nombre de pixel correspondant à la distance entre le rayon et la valeur moyenne
        var deltaMax = rayon - maxPixelValue;     //nombre de pixel correspondant à la distance entre le rayon et la valeur moyenne sup.
        var deltaMin = rayon - minPixelValue;     //nombre de pixel correspondant à la distance entre le rayon et la valeur moyenne inf.
        var deltaRes = rayon - resultPixelValue;  //nombre de pixel correspondant à la distance entre le rayon et la valeur resultat

        // Utile pour le calcul des extremités
        maxValueArray.push(maxPixelValue);
        /* fonction qui permet de calculer les coordonnees des points sur le cercle trigo en fonction de sa distance sur le rayon par rapport au point de reference du cercle */
        function calcCoord(point, delta){
          point.x = data[i][typeProp].x + (middlePoint.x - data[i][typeProp].x) * delta / rayon;
          point.y = data[i][typeProp].y + (middlePoint.y - data[i][typeProp].y) * delta / rayon;
        }

        // Calcul des coordonnées des points correspondants à la moyenne.
        calcCoord(data[i].coordMoy, deltaMoy);
        // Calcul des coordonnées des points correspondants à la moyenne max.
        calcCoord(data[i].coordMoyMax, deltaMax);
        // Calcul des coordonnées des points correspondants à la moyenne min.
        calcCoord(data[i].coordMoyMin, deltaMin);
        // Calcul des coordonnées des points correspondants aux résultats.
        calcCoord(data[i].coordResultat, deltaRes);
      }

      // Calcul des coordonnées des points correspondants aux extrémités des lignes qui se croisent en leur centre.
      for(var i = 0, length = data.length; i < length; i++ ){
        var rayon = pythagore(middlePoint.x,middlePoint.y,data[i][typeProp].x,data[i][typeProp].y);
        var deltaExt = rayon - (Math.max(...maxValueArray) + EXCES);
        data[i].coordLim.x = data[i][typeProp].x + (middlePoint.x - data[i][typeProp].x) * deltaExt / rayon;
        data[i].coordLim.y = data[i][typeProp].y + (middlePoint.y - data[i][typeProp].y) * deltaExt / rayon;
      }

      (function drawText(returnHeight, maxTextWidth){
        // On ne reduit la zone de texte pas au dela de la taille de 3 lettre M affichees dans la font et le style utilise
        if(maxTextWidth < context.measureText("MM").width){
          maxTextWidth = context.measureText("MM").width;
        }

        deltaExt-=75;
        
        for(var i = 0, length = data.length; i < length; i++ ){
          
          var text = data[i].nom + " " + data[i].categorie;

          var middleText;

          var textArray = [];
          var isTextPushed = false;

          var text1 = "";
          var text2 = "";
          var textWidth;

          // fonction recursive qui permet de sauter une ou plusieurs lignes du texte si celui-ci est superieur a une longueur max donnee
          (function cut(str){
            isTextPushed = false;
            text1 = str;
            textWidth = context.measureText(text1).width;
            if (textWidth > maxTextWidth) {
              if(text1.search(/ /) != -1){
                text1 = text1.split(" ");
                text2 = text2 === "" ? " " + text1.pop() : " " + text1.pop() + text2;
                text1 = text1.join(" ");
                cut(text1);
              } else {
                var temp = text1;
                text1 = text1.substring(0,text1.length/2);
                text2 = temp.substring(temp.length/2) + text2;
                cut(text1);
              }
            } 
            if(text2[0] === " "){
              text2 = text2.substring(1);
            }
            if(!isTextPushed){
              textArray.push(text1);
              if(context.measureText(text2).width > maxTextWidth){
                var textTemp = text2;
                text2 = "";
                cut(textTemp);
              } else {
                textArray.push(text2);
              }
              isTextPushed = true;
            }
            return;
          })(text);
          
          textWidth = context.measureText(textArray[0]).width;
          middleText = textWidth/2;

          context.fillText(
            textArray[0], 
            - middleText + data[i][typeProp].x + (middlePoint.x - data[i][typeProp].x) * deltaExt / rayon, 
            data[i][typeProp].y + (middlePoint.y - data[i][typeProp].y) * deltaExt / rayon
          );

          var line = returnHeight;

          for(var j = 1; j < textArray.length; j++){
            context.fillText(
              textArray[j], 
              - middleText + data[i][typeProp].x + (middlePoint.x - data[i][typeProp].x) * deltaExt / rayon, 
              line + data[i][typeProp].y + (middlePoint.y - data[i][typeProp].y) * deltaExt / rayon
            );
            line+=returnHeight;
          }
        }
      })(returnHeight,maxTextWidth);
    }


    function drawPoints(style,prop,fill,lineWidth,cross){
      if(fill){
        context.fillStyle = style;
      } else {
        context.lineWidth = lineWidth ? lineWidth : "1";
        context.strokeStyle = style;
      }

      context.beginPath();
      context.moveTo(data[0][prop].x, data[0][prop].y);
      if(cross){
        context.lineTo(middlePoint.x,middlePoint.y);
      }
      for(var i = 1, length = data.length; i < length; i++ ){
        if(cross){
          context.moveTo(data[i][prop].x, data[i][prop].y);
          context.lineTo(middlePoint.x,middlePoint.y);
        } else {
          context.lineTo(data[i][prop].x,data[i][prop].y);
        }
      }
      context.closePath();
      if(fill){
        context.fill();
      } else {
        context.stroke();
      }

      
      /*function step(timestamp) {
        
        if(fill){
          context.fillStyle = style;
        } else {
          context.lineWidth = lineWidth ? lineWidth : "1";
          context.strokeStyle = style;
        }

        context.beginPath();
        context.moveTo(data[0][prop].x, data[0][prop].y);
        if(cross){
          context.lineTo(middlePoint.x,middlePoint.y);
        }
        for(var i = 1, length = data.length; i < length; i++ ){
          if(cross){
            context.moveTo(data[i][prop].x, data[i][prop].y);
            context.lineTo(middlePoint.x,middlePoint.y);
          } else {
            context.lineTo(data[i][prop].x,data[i][prop].y);
          }
        }



        context.closePath();clearCanvas();
        if(fill){
          context.fill();
        } else {
          context.stroke();
        }

        if (x != middlePoint.x) {
          requestAnimationFrame(step);
          //step();
        }

        x+=25;
      }
      //step();
      requestAnimationFrame(step);*/
    }

    /**
     * Tracé des courbes
     */
    function draw(){
      drawPoints("rgba(23, 145, 167, 0.3)","coordMoyMax",true);
      drawPoints("rgba(255, 255, 255, 1)","coordMoyMin",true);
      drawPoints("rgba(255, 0, 0, .5)","coordResultat",true);
      drawPoints("rgba(150, 150, 150, .5)","coordLim",false,"2",true);
      drawPoints("rgba(255, 0, 0, 1)","coordResultat",false,"2");
      drawPoints("rgba(80, 0, 160, .6)","coordMoy",false,"3");
    }

    /**
     * Calcul des points
     */
    clearCanvas();
    type = "MAX"; 
    computeCoord(RETURNHEIGHT,MAXTEXTWIDTH);
    draw();

    function changeTextWidth(val){
      clearCanvas();
      computeCoord(RETURNHEIGHT,val);
      draw();
    }
    
    // Bouton de telechargement du diagramme en jpeg
    downloadLnk.addEventListener('click', function(){
        this.href = canvas.toDataURL('image/jpeg');
    }, false);

    moy.addEventListener('click', function(){
      clearCanvas();
      type = "MOY"; 
      computeCoord(RETURNHEIGHT, MAXTEXTWIDTH);
      draw();
    }, false);

    max.addEventListener('click', function(){
      clearCanvas();
      type = "MAX"; 
      computeCoord(RETURNHEIGHT, MAXTEXTWIDTH);
      draw();
    }, false);

    min.addEventListener('click', function(){
      clearCanvas();
      type = "MIN";
      computeCoord(RETURNHEIGHT, MAXTEXTWIDTH);
      draw();
    }, false);

    res.addEventListener('click', function(){
      clearCanvas();
      type = "RES";
      computeCoord(RETURNHEIGHT, MAXTEXTWIDTH);
      draw();
    }, false);



  </script>
  
</body>
</html>
